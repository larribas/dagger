"""Build DAGs through an imperative domain-specific language."""

import inspect
from contextvars import Context, copy_context
from itertools import groupby
from typing import Callable, Mapping, Union

from dagger.dag import DAG
from dagger.dag import SupportedInputs as SupportedDAGInputs
from dagger.dsl.context import node_invocations
from dagger.dsl.invocations import DAGInvocation, ParameterUsage, TaskInvocation
from dagger.input import FromNodeOutput
from dagger.task import SupportedInputs as SupportedTaskInputs
from dagger.task import Task

Node = Union[Task, DAG]


class DAGBuilder:
    """
    Builds a DAG using the imperative DSL.

    When an instance of this class is invoked, it initializes a new context
    and calls the supplied build function.

    All the nodes, inputs and outputs that were used during the construction of the DAG
    are captured by the context and then rendered as a DAG data structure.
    """

    def __init__(self, build_func: Callable):
        self._build_func = build_func

    def __call__(self, *args, **kwargs):
        """Invoke the builder function and return a DAG data structure it defines."""
        # The parameters expected by the build function are assumed to be the parameters expected by the DAG.
        parameters = {
            param_name: ParameterUsage(name=param_name)
            for param_name in inspect.signature(self._build_func).parameters
        }

        # We initialize a new context and invoke the build function inside of it.
        # All node, input and output invocations are thus isolated from other
        # build functions invoked before, during or after this one.
        ctx = copy_context()
        ctx.run(self._build_func, **parameters)

        return DAG(
            nodes=self._named_node_invocations(ctx),
            inputs=self._named_dag_inputs(parameters),
        )

    def _named_dag_inputs(
        self, parameters: Mapping[str, ParameterUsage]
    ) -> Mapping[str, SupportedDAGInputs]:
        return {input_name: input.FromParam() for input_name in parameters}

    def _named_node_invocations(self, ctx: Context) -> Mapping[str, Node]:
        # Translate invocation ids (which are not supposed to be human-readable)
        # into meaningful (but still unique) node names
        node_names_by_id = {}
        for node_name, group in groupby(
            ctx[node_invocations], key=lambda invocation: invocation.name
        ):
            nodes_with_the_same_name = list(group)

            if len(nodes_with_the_same_name) == 1:
                node_names_by_id[nodes_with_the_same_name[0].id] = node_name
            else:
                for i in range(0, len(nodes_with_the_same_name)):
                    node_names_by_id[
                        nodes_with_the_same_name[i].id
                    ] = f"{node_name}-{i+1}"

        nodes = {}
        for node_invocation in ctx[node_invocations]:
            node_name = node_names_by_id[node_invocation.id]
            nodes[node_name] = self._build_node(
                invocation=node_invocation,
                node_names_by_id=node_names_by_id,
            )

        return nodes

    def _build_node(
        self,
        invocation: Union[TaskInvocation, DAGInvocation],
        node_names_by_id: Mapping[str, str],
    ) -> Node:
        """Build a node (a task or DAG) based on the data collected during its invocation."""
        if isinstance(invocation, TaskInvocation):
            return Task(
                invocation.func,
                inputs=self._build_task_inputs(invocation.inputs, node_names_by_id),
                # TODO: Decouple the building of the outputs from the data structure that indicates how they were used
                outputs=invocation.output._build_outputs(),
            )
        else:
            raise NotImplementedError()

    def _build_task_inputs(
        self,
        inputs: Mapping[str, SupportedTaskInputs],
        node_names_by_id: Mapping[str, str],
    ) -> Mapping[str, SupportedTaskInputs]:
        """
        Build the inputs for a task.

        If an input references the output of another node by name, it will reference it
        by its unique invocation ID. This method ensures all those references are translated
        into the unique, human-readable name that was generated by this builder.
        """
        inputs = {}
        for input_name, input_type in inputs:
            if isinstance(input_type, FromNodeOutput):
                inputs[input_name] = FromNodeOutput(
                    node=node_names_by_id[input_type.node],
                    output=input_type.output,
                    serializer=input_type.serializer,
                )
            else:
                inputs[input_name] = input_type

        return inputs
